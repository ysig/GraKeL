

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Core Concepts &mdash; GraKeL 0.1a7 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/_static/css/supplementary.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Creating your Own Kernel" href="creating_kernels.html" />
    <link rel="prev" title="A Short Introduction" href="introduction.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> GraKeL
          

          
            
            <img src="../_static/logo.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1a7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../documentation.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="installation.html">Installing GraKeL</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html">A Short Introduction</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Core Concepts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-is-the-graphkernel-class">What is the <cite>GraphKernel</cite> Class?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-kernel-class">The <cite>Kernel</cite> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#why-not-a-more-structured-input-for-graphs">Why not a more structured input for Graphs?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="creating_kernels.html">Creating your Own Kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html">Contributing</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks.html">Benchmarks</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api.html">GraKeL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../classes.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GraKeL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../documentation.html">Documentation</a> &raquo;</li>
        
      <li>Core Concepts</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/documentation/core_concepts.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="core-concepts">
<span id="id1"></span><h1>Core Concepts<a class="headerlink" href="#core-concepts" title="Permalink to this headline">¶</a></h1>
<p>We next present some core concepts in <em>GraKeL</em>.</p>
<div class="section" id="what-is-the-graphkernel-class">
<h2>What is the <cite>GraphKernel</cite> Class?<a class="headerlink" href="#what-is-the-graphkernel-class" title="Permalink to this headline">¶</a></h2>
<p>The <cite>GraphKernel</cite> class is a <em>generic wrapper class</em>. This class provides a uniform interface for all the implemented graph kernels and frameworks. A graph kernel can be described by an instance of this class, and it holds the attributes listed below:</p>
<ul>
<li><dl class="first docutils">
<dt><code class="code docutils literal notranslate"><span class="pre">kernel</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">Specifies the graph kernel to be computed. It can be either a <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> or a list that contains one or more <code class="code docutils literal notranslate"><span class="pre">framework</span></code> along with exactly one <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code>. The <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> needs to be the last element in the list.</span></dt>
<dd><ul class="first simple">
<li><code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> : Α <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> is a kernel that compares graphs to each other. It is represented by a dictionary which contains a key <code class="code docutils literal notranslate"><span class="pre">'name'</span></code> whose value  corresponds to the name of the kernel. The dictionary can also contain other keys that specify the parameters of the kernel and their values. For instance, we can initialize a shortest path kernel as follows.</li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;shortest_path&quot;</span><span class="p">,</span> <span class="s2">&quot;with_labels&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">})</span>
</pre></div>
</div>
<ul class="simple">
<li><code class="code docutils literal notranslate"><span class="pre">framework</span></code> : A <code class="code docutils literal notranslate"><span class="pre">framework</span></code> works on top of graph kernels. It takes a <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> as input. Frameworks correspond to dictionaries that contain their name as the value of the key <code class="code docutils literal notranslate"><span class="pre">'name'</span></code>, and their parameters. A <code class="code docutils literal notranslate"><span class="pre">framework</span></code> combined with a <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> corresponds to a <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> and can be passed on to another <code class="code docutils literal notranslate"><span class="pre">framework</span></code>. For example, a kernel that applies the Weisfeiler-Lehman framework on top of the shortest path kernel is initialized as follows.</li>
</ul>
<div class="last highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;n_iter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;shortest_path&quot;</span><span class="p">}])</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="code docutils literal notranslate"><span class="pre">normalize</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">A kernel can provide either an unnormalized or a normalized output.</span></dt>
<dd><p class="first">The normalized kernel value between two graphs <span class="math notranslate nohighlight">\(G_1\)</span> and <span class="math notranslate nohighlight">\(G_2\)</span> is computed as follows: <span class="math notranslate nohighlight">\(k(G_1, G_2)/\sqrt{k(G_1, G_1) k(G_2, G_2)}\)</span>. This normalization ensures that the kernel value between a graph and itself is equal to 1, while the kernel value between a graph and any other graph takes values between 0 and 1.</p>
<div class="line-block">
<div class="line"><strong>Example</strong></div>
</div>
<p>Suppose we have a set of training graphs <code class="code docutils literal notranslate"><span class="pre">G_train</span></code>, and a set of test graphs <code class="code docutils literal notranslate"><span class="pre">G_test</span></code>. We compute the normalized kernel matrices using the Weisfeiler-Lehman subtree kernel as follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;n_iter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;subtree_wl&quot;</span><span class="p">}],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Calculate the normalized kernel matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_train</span> <span class="o">=</span> <span class="n">gk</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">G_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_test</span> <span class="o">=</span> <span class="n">gk</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">G_test</span><span class="p">)</span>
</pre></div>
</div>
<p>The above is equivalent (for deterministic kernels) to the code below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;n_iter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;subtree_wl&quot;</span><span class="p">}],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">gk</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_diag</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_train_diag</span><span class="p">,</span> <span class="n">K_test_diag</span> <span class="o">=</span> <span class="n">K_diag</span><span class="p">[</span><span class="n">idx_train</span><span class="p">],</span> <span class="n">K_diag</span><span class="p">[</span><span class="n">idx_test</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Calculate the normalized kernel matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_train</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">idx_train</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">idx_train</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">K_train_diag</span><span class="p">,</span> <span class="n">K_train_diag</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_test</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">idx_test</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">idx_train</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">K_test_diag</span><span class="p">,</span> <span class="n">K_train_diag</span><span class="p">))</span>
</pre></div>
</div>
<p class="last">Note that in the second case, we perform more computations since we also compare the graphs of the test set to each other.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="code docutils literal notranslate"><span class="pre">Nystroem</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">The Nyström method is a well-established approach for approximating kernel matrices on large datasets.</span></dt>
<dd><p class="first">If <span class="math notranslate nohighlight">\(n\)</span> is the number of samples, computing and storing the kernel matrix requires <span class="math notranslate nohighlight">\(\mathcal{O}(n^2)\)</span> time and memory, respectively. Therefore, applying kernel methods will become unfeasible when <span class="math notranslate nohighlight">\(n\)</span> is large. The Nyström approximation can allow a significant speed-up of the calculations by computing an approximation <span class="math notranslate nohighlight">\(\tilde{\mathbf{K}}\)</span> of rank <span class="math notranslate nohighlight">\(q\)</span> of the kernel matrix. The method uses a subset of the training data as basis and reduces the storage and complexity requirements to <span class="math notranslate nohighlight">\(\mathcal{O}(n q)\)</span>. The value of <span class="math notranslate nohighlight">\(q\)</span> is specified by the user by setting <code class="code docutils literal notranslate"><span class="pre">Nystroem</span></code> equal to an integer value. An example demonstrating the power of the Nyström method is given below.</p>
<div class="line-block">
<div class="line"><strong>Example</strong></div>
</div>
<p>We first download the MUTAG dataset and split it into a training and a test set.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel.datasets</span> <span class="kn">import</span> <span class="n">fetch_dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MUTAG</span> <span class="o">=</span> <span class="n">fetch_dataset</span><span class="p">(</span><span class="s2">&quot;MUTAG&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G_train</span><span class="p">,</span> <span class="n">G_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>We next initialize a Weisfeiler-Lehman subtree kernel using <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code>, and we also make use of <code class="code docutils literal notranslate"><span class="pre">Nystroem</span></code> with <span class="math notranslate nohighlight">\(q=20\)</span> to approximate the kernel matrix.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;n_iter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="s2">&quot;subtree_wl&quot;</span><span class="p">],</span> <span class="n">Nystroem</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_train</span> <span class="o">=</span> <span class="n">gk</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">G_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_test</span> <span class="o">=</span> <span class="n">gk</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">G_test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">K_train</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(169, 20)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">K_test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(19, 20)</span>
</pre></div>
</div>
<p>Then, we train a standard SVM classifier with linear kernel, and use the classifier to make predictions.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">K_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="go">SVC(C=1.0, break_ties=False, cache_size=200, class_weight=None, coef0=0.0,</span>
<span class="go">    decision_function_shape=&#39;ovr&#39;, degree=3, gamma=&#39;scale&#39;, kernel=&#39;linear&#39;,</span>
<span class="go">    max_iter=-1, probability=False, random_state=None, shrinking=True,</span>
<span class="go">    tol=0.001, verbose=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">K_test</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we calculate the classification accuracy.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="s2">&quot;%&quot;</span><span class="p">)</span>
<span class="go">78.95 %</span>
</pre></div>
</div>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<div class="last line-block">
<div class="line">To compute the full kernel matrices, we needed to perform <span class="math notranslate nohighlight">\(~ 169 * (169-1) /2 + 19 * 169 = 17,407\)</span> kernel computations. Instead, we performed <span class="math notranslate nohighlight">\(~ 20 * (20-1)/ 2 + 20 * 169 + 20* 19 = 3,950\)</span> kernel computations. As we can see, the approximation led only to a slight decrease in performance.</div>
</div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="code docutils literal notranslate"><span class="pre">n_jobs</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">Some kernels consist of operations that can be executed in parallel, leading to a reduction in the running time.</span></dt>
<dd><p class="first">The <code class="code docutils literal notranslate"><span class="pre">n_jobs</span></code> attribute has the same functionality as that of scikit-learn. It determines the number of jobs that will run in parallel. If <code class="code docutils literal notranslate"><span class="pre">n_jobs</span></code> is set equal to -1, all the processors will be utilized. Note that this attribute will not have an impact on the computation of some kernels whose code is not parallelized. These kernels either take advantage of the parallelization inherent in other libraries (e.g., NumPy) or their code is only partially parallelizable or not parallelizable at all. In such scenarios, a warning is issued.</p>
<p class="last">If you are interested in parallelizing any of the implemented kernels, you can <em>contribute</em> to the <em>GraKeL</em> project. To find out how you can contribute, please have a look at <a class="reference internal" href="contributing.html#contributing"><span class="std std-ref">Contributing</span></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="code docutils literal notranslate"><span class="pre">random_state</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">This attribute is used for initializing the internal random number generator.</span></dt>
<dd><p class="first">It has no effect on deterministic graph kernels, but only on kernels that involve some random process (e.g., those that perform sampling). It also applies to the <code class="code docutils literal notranslate"><span class="pre">Nystroem</span></code> function of the <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code> class which also performs sampling. If int, <code class="code docutils literal notranslate"><span class="pre">random_state</span></code> is the seed used by the random number generator. Otherwise, it can be a <code class="code docutils literal notranslate"><span class="pre">RandomState</span></code> instance. If <code class="code docutils literal notranslate"><span class="pre">None</span></code>, the random number generator is the <code class="code docutils literal notranslate"><span class="pre">RandomState</span></code> instance used by <code class="code docutils literal notranslate"><span class="pre">np.random</span></code>. The use of <code class="code docutils literal notranslate"><span class="pre">random_state</span></code> is illustrated in the following example.</p>
<div class="line-block">
<div class="line"><strong>Example</strong></div>
</div>
<p>We first create the graph representations of the following two molecules: (1) water <span class="math notranslate nohighlight">\(\mathbf{H}_{2}\mathbf{O}\)</span> and (2) hydronium <span class="math notranslate nohighlight">\(\mathbf{H}_{3}\mathbf{O}^{+}\)</span>, an ion of water produced by protonation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">Graph</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O_adjacency</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O_node_labels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">initialization_object</span><span class="o">=</span><span class="n">H2O_adjacency</span><span class="p">,</span> <span class="n">node_labels</span><span class="o">=</span><span class="n">H2O_node_labels</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H3O_adjacency</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H3O_node_labels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;H&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H3O</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">initialization_object</span><span class="o">=</span><span class="n">H3O_adjacency</span><span class="p">,</span> <span class="n">node_labels</span><span class="o">=</span><span class="n">H3O_node_labels</span><span class="p">)</span>
</pre></div>
</div>
<p>We will then compute the <em>graphlet kernel</em> between the two molecules. The graphlet kernel counts the number of common graphlets (i.e., small subgraphs) in two graphs. Instead of exaustively enumerating all the graphlets, it usually samples a number of them. In this example, we will sample 5 graphlets from each graph.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;graphlet_sampling&quot;</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">H2O</span><span class="p">)</span>
<span class="go">GraphKernel(Nystroem=False,</span>
<span class="go">      kernel={&#39;name&#39;: &#39;graphlet_sampling&#39;, &#39;sampling&#39;: {&#39;n_samples&#39;: 5}},</span>
<span class="go">      n_jobs=None, normalize=False, random_state=None, verbose=False)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">H3O</span><span class="p">)</span>
<span class="go">array([[10.]])</span>
</pre></div>
</div>
<p>Note that we did not set <code class="code docutils literal notranslate"><span class="pre">random_state</span></code> to some value, and therefore it took its default <code class="code docutils literal notranslate"><span class="pre">None</span></code> value. We will now set <code class="code docutils literal notranslate"><span class="pre">random_state</span></code> equal to 42.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;graphlet_sampling&quot;</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">H2O</span><span class="p">)</span>
<span class="go">GraphKernel(Nystroem=False,</span>
<span class="go">      kernel={&#39;name&#39;: &#39;graphlet_sampling&#39;, &#39;sampling&#39;: {&#39;n_samples&#39;: 5}, &#39;random_state&#39;: 42},</span>
<span class="go">      n_jobs=None, normalize=False, random_state=None, verbose=False)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">H3O</span><span class="p">)</span>
<span class="go">array([[15.]])</span>
</pre></div>
</div>
<p>As you can see, the new kernel value is not equal to the previous one. If we re-run the above code, we will obtain the same kernel value since the algorithm will sample exactly the same graphlets from both graphs. As shown below, we can also obtain the same kernel value if <code class="code docutils literal notranslate"><span class="pre">random_state</span></code> is initialized as an attribute of <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code> instead of the graphlet kernel itself.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;graphlet_sampling&quot;</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">)),</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">H2O</span><span class="p">)</span>
<span class="go">GraphKernel(Nystroem=False,</span>
<span class="go">      kernel={&#39;name&#39;: &#39;graphlet_sampling&#39;, &#39;sampling&#39;: {&#39;n_samples&#39;: 5}},</span>
<span class="go">      n_jobs=None, normalize=False, random_state=42, verbose=False)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">H3O</span><span class="p">)</span>
<span class="go">array([[15.]])</span>
</pre></div>
</div>
<p>If we provide a <code class="code docutils literal notranslate"><span class="pre">random_state</span></code> value to both <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code> and <code class="code docutils literal notranslate"><span class="pre">kernel</span></code>, then each one will have an effect only on the corresponding instances.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;graphlet_sampling&quot;</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">H2O</span><span class="p">)</span>
<span class="go">GraphKernel(Nystroem=False,</span>
<span class="go">      kernel={&#39;name&#39;: &#39;graphlet_sampling&#39;, &#39;sampling&#39;: {&#39;n_samples&#39;: 5, &#39;random_state&#39;: 0}},</span>
<span class="go">      n_jobs=None, normalize=False, random_state=42, verbose=False)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">H3O</span><span class="p">)</span>
<span class="go">array([[15.]])</span>
</pre></div>
</div>
<p>while</p>
<div class="last highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;graphlet_sampling&quot;</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">)),</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">H2O</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">H3O</span><span class="p">)</span>
<span class="go">array([[10.]])</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="code docutils literal notranslate"><span class="pre">verbose</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">Currently not supported.</span></dt>
<dd><div class="first last admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="code docutils literal notranslate"><span class="pre">verbose</span></code> is an attribute that is currently not supported, but may be supported in the future for printing progress messages.</p>
</div>
</dd>
</dl>
</li>
</ul>
<p>We will next focus on the <code class="code docutils literal notranslate"><span class="pre">Kernel</span></code> class. Instances of this class are wrapped in an instance of the <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code> class.</p>
</div>
<div class="section" id="the-kernel-class">
<h2>The <cite>Kernel</cite> class<a class="headerlink" href="#the-kernel-class" title="Permalink to this headline">¶</a></h2>
<p>This <code class="code docutils literal notranslate"><span class="pre">Object</span></code> is any object inherited from the <a class="reference internal" href="../kernels/kernel.html#kernel"><span class="std std-ref">Kernel (general class)</span></a> (which can be imported from <code class="code docutils literal notranslate"><span class="pre">grakel</span></code>).</p>
<p>Normally a kernel function, between graphs should be considered as a function with to arguments,
such as <span class="math notranslate nohighlight">\(k \; : \; \mathcal{G} \times \mathcal{G} \rightarrow \mathbb{R}\)</span>.
This raises two issues, namely one of efficiency and one of compatibility:</p>
<ol class="arabic simple">
<li>The first one has to do with the fact, that there are major computational advantages if instead of calculating the kernel pairwise, we calculate the whole kernel matrix.</li>
<li>The second has to do with the fact, that we wanted our project to be integrable inside the <a class="reference external" href="https://github.com/scikit-learn-contrib/project-template">sk learn template</a>. From this template the most relevant structure was the sci-kit transformer, which consists of three inherent methods: <code class="code docutils literal notranslate"><span class="pre">fit</span></code>, <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code>, <code class="code docutils literal notranslate"><span class="pre">transform</span></code>.</li>
</ol>
<p>So the way we conceptually attached the kernel definition to that design pattern was:</p>
<ul class="simple">
<li>The <code class="code docutils literal notranslate"><span class="pre">fit</span></code> part should fix a graph dataset as the base of comparison calculating necessary features.</li>
<li>The <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code> should fit and calculate the kernel matrix on the fitted dataset.</li>
<li>The <code class="code docutils literal notranslate"><span class="pre">transform</span></code> should calculate the matrix produced between a new dataset (namely the <em>test</em>) and the fitted dataset.</li>
</ul>
<p>The deconstruction of the kernel matrix calculation from a function <span class="math notranslate nohighlight">\(\mathcal{K}: \mathcal{G}^{\text{train}} \times \mathcal{G}^{\text{test}} \rightarrow \mathbb{R}^{n_{\text{test}}} \times \mathbb{R}^{n_{\text{train}}}\)</span>
to a <a class="reference external" href="https://en.wikipedia.org/wiki/Currying">currying</a> scheme <span class="math notranslate nohighlight">\(\mathcal{K}: \mathcal{G}^{\text{train}} \rightarrow \mathcal{G}^{\text{test}} \rightarrow \mathbb{R}^{n_{\text{test}}} \times \mathbb{R}^{n_{\text{train}}}\)</span> is not always equivalent in the
result, if some of the data of <span class="math notranslate nohighlight">\(\mathcal{G}^{\text{train}}\)</span>, must be combined with data of <span class="math notranslate nohighlight">\(\mathcal{G}^{\text{test}}\)</span> to produce the fit reference-features. In such cases
as mentioned above, namely in the case of <code class="code docutils literal notranslate"><span class="pre">multiscale_laplacian</span></code>, if the user wants <span class="math notranslate nohighlight">\(\mathcal{G}^{\text{train}} \rightarrow \mathcal{G}^{\text{test}}\)</span> to be concerned
before fit we advise him to use the <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code>, function in the whole of the train and test data and separate the kernel matrices on the result.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The very idea that lies before fitting concerns holding a reference dataset. This means a collections of features should be stored into memory and <strong>not</strong> get corrupted throughout various applications of <code class="code docutils literal notranslate"><span class="pre">transform</span></code>. This however - the need of copying and protecting the reference data - produces a computational overhead in kernels such as the <code class="code docutils literal notranslate"><span class="pre">odd_sth</span></code> where the user will may prefer the computational advantages of applying a sole <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code>.</p>
</div>
<p>Using a <code class="code docutils literal notranslate"><span class="pre">Kernel</span></code> type object through the generic wrapper, should be equivalent with doing so without the generic wrapper, if the correct parametrization is given.
The generic wrapper <strong>does not</strong> restrict any <em>user-oriented</em> interface of the kernels, except if the user wants to write a kernel of his own.
If you want to know more about the kernel structure in order to write your own see <a class="reference internal" href="creating_kernels.html#myok"><span class="std std-ref">Creating your Own Kernel</span></a>.</p>
<p>To demonstrate a small example of the above we will construct our own a WL-subtree kernel instead of using the generic wrapper.
To do so first import the <code class="code docutils literal notranslate"><span class="pre">WeisfeilerLehman</span></code> and <code class="code docutils literal notranslate"><span class="pre">VertexHistogram</span></code> (where <code class="code docutils literal notranslate"><span class="pre">vertex_histogram</span></code> is equivalent
with the <code class="code docutils literal notranslate"><span class="pre">subtree_kernel</span></code>) kernels as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">WeisfeilerLehman</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">VertexHistogram</span>
</pre></div>
</div>
<p>If we see the documentation of <a class="reference internal" href="../kernels/weisfeiler_lehman.html#weisfeiler-lehman"><span class="std std-ref">Weisfeiler Lehman Framework</span></a>, we can see that it accepts two arguments upon initialization: a <code class="code docutils literal notranslate"><span class="pre">niter</span></code> and a <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code>. The <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> is a tuple consisting of a <code class="code docutils literal notranslate"><span class="pre">kernel</span></code> type object and a dictionary of arguments. To initialize a Weisfeiler-Lehman with 5 iterations and a subtree base-kernel.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wl_kernel</span> <span class="o">=</span> <span class="n">WeisfeilerLehman</span><span class="p">(</span><span class="n">niter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">base_graph_kernel</span><span class="o">=</span><span class="p">(</span><span class="n">VertexHistogram</span><span class="p">,</span> <span class="p">{}))</span>
</pre></div>
</div>
<p>This is also equivalent with doing (as long as we have no arguments)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wl_kernel</span> <span class="o">=</span> <span class="n">WeisfeilerLehman</span><span class="p">(</span><span class="n">niter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">base_graph_kernel</span><span class="o">=</span><span class="n">VertexHistogram</span><span class="p">)</span>
</pre></div>
</div>
<p>Now let’s go back again to our favorite MUTAG problem.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MUTAG</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">fetch_dataset</span><span class="p">(</span><span class="s2">&quot;MUTAG&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MUTAG_data</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_point</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MUTAG_data</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">MUTAG_data</span><span class="p">[:</span><span class="n">split_point</span><span class="p">],</span> <span class="n">MUTAG_data</span><span class="p">[</span><span class="n">split_point</span><span class="p">:]</span>
</pre></div>
</div>
<p>If what we said till now is correct, the <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code> object should produce the same kernel matrix output on the MUTAG train/test data split.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wl_graph_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;niter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;subtree_wl&quot;</span><span class="p">}])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The alias &quot;subtree_wl&quot; is supported inside the generic wrapper</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array_equal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array_equal</span><span class="p">(</span><span class="n">wl_graph_kernel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">wl_kernel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array_equal</span><span class="p">(</span><span class="n">wl_graph_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span> <span class="n">wl_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="why-not-a-more-structured-input-for-graphs">
<h2>Why not a more structured input for Graphs?<a class="headerlink" href="#why-not-a-more-structured-input-for-graphs" title="Permalink to this headline">¶</a></h2>
<p>The flattened input type provided for all kernels (graph-dictionary/adjacency, node-labels, edge-labels) may raise the question,
why does not this library, accept a well known type of Graph input as the one constructed from <a class="reference external" href="https://networkx.github.io/">networkx</a> or <a class="reference external" href="http://igraph.org/python/">igraph</a>.
Networkx library is known for producing a very big memory overhead, which seems unimportant when the user wants to use
very basic graph methods such calculating shortest paths or getting a vertex neighbor. Because what we wanted to wrap
around a graph class was really simple: conversion between dictionary and adjacency formats, format agnostic - format imposing
methods and very basic graph oriented supplementary methods, such as <em>Shortest-Path matrix</em> calculation, we designed
a Graph class of our own, used inside most of our kernels, in order to resolve to a common object - graph format reference.
This specificity of kernel format, as well as the absence of a need for complex calculations concerning the field of graphs
lead us to the creation of <a class="reference internal" href="../graph.html#graph"><span class="std std-ref">Graph (class)</span></a>.</p>
<p>Let’s go back to the H2O example:
First we will import the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> object from <code class="code docutils literal notranslate"><span class="pre">Grakel</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">Graph</span>
</pre></div>
</div>
<p>Firstly let’s collect all the dictionary formats and show that they are equivalent.
We start by calculating a graph object for the native format of graph dictionary which corresponds to the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">},</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}}</span>
</pre></div>
</div>
<p>Now let’s initialize all the other</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">):</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="mf">1.</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)]</span>
</pre></div>
</div>
<p>and compute the result</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">any</span><span class="p">(</span><span class="n">Graph</span><span class="p">(</span><span class="n">H2Od</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">get_edge_dictionary</span><span class="p">()</span> <span class="o">==</span> <span class="n">H2Od</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Now let’s do the same for adjacency matrix type formats. The numpy array is the native adjacency-matrix format:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
</pre></div>
</div>
<p>and with the conversion of other input type formats</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>we can demonstrate equality as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array_equal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">all</span><span class="p">(</span><span class="n">array_equal</span><span class="p">(</span><span class="n">Graph</span><span class="p">(</span><span class="n">H2O</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">get_adjacency_matrix</span><span class="p">(),</span> <span class="n">H2O</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Now we would like to initialize two <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> type objects one for adjacency_matrix and one for edge_dictionary and show that they are equivalent (using also labels).
First initialize the graph object, created from an adjacency matrix:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2O_labels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O_edge_labels</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj_graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">H2O</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">H2O_labels</span><span class="p">,</span> <span class="n">H2O_edge_labels</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>and one from an edge dictionary:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od_labels</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od_edge_labels</span> <span class="o">=</span> <span class="p">{(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edge_dict_graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">H2Od</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">H2Od_labels</span><span class="p">,</span> <span class="n">H2Od_edge_labels</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Firstly we will demonstrate equality of graph type formats:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">array_equal</span><span class="p">(</span><span class="n">adj_graph</span><span class="o">.</span><span class="n">get_adjacency_matrix</span><span class="p">(),</span> <span class="n">edge_dict_graph</span><span class="o">.</span><span class="n">get_adjacency_matrix</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">adj_graph</span><span class="o">.</span><span class="n">get_edge_dictionary</span><span class="p">()</span> <span class="o">==</span> <span class="n">edge_dict_graph</span><span class="o">.</span><span class="n">get_edge_dictionary</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>and afterwards between labels for <code class="code docutils literal notranslate"><span class="pre">&quot;adjacency&quot;</span></code> object formats, defined by the <code class="code docutils literal notranslate"><span class="pre">purpose</span></code> argument of the <code class="code docutils literal notranslate"><span class="pre">get_labels</span></code> method from the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> type object and for both vertices or edges defined by the <code class="code docutils literal notranslate"><span class="pre">label_type</span></code> format of the same method, as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">all</span><span class="p">((</span><span class="n">adj_graph</span><span class="o">.</span><span class="n">get_labels</span><span class="p">(</span><span class="n">purpose</span><span class="o">=</span><span class="s2">&quot;adjacency&quot;</span><span class="p">,</span> <span class="n">label_type</span><span class="o">=</span><span class="n">lt</span><span class="p">),</span> <span class="n">edge_dict_graph</span><span class="o">.</span><span class="n">get_labels</span><span class="p">(</span><span class="n">purpose</span><span class="o">=</span><span class="s2">&quot;adjacency&quot;</span><span class="p">,</span> <span class="n">label_type</span><span class="o">=</span><span class="n">lt</span><span class="p">))</span> <span class="k">for</span> <span class="n">lt</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;vertex&quot;</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking equality of the inverse (“edge_dictionary”) want hold, because the adjacency matrix, when initialized does not have information about the vertex symbols.
Here we should emphasize that <strong>vertex symbols should be a :code:`sortable` in order for an indexing to be possible</strong>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>When initializing a <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> object the 4th argument (named <code class="code docutils literal notranslate"><span class="pre">graph_format</span></code>), corresponds to the format the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> will be stored to. The default value of this argument is <code class="code docutils literal notranslate"><span class="pre">&quot;auto&quot;</span></code>, which stores the graph in the given format, if it is valid. Explicit format “choices” such as <code class="code docutils literal notranslate"><span class="pre">&quot;adjacency&quot;</span></code> or <code class="code docutils literal notranslate"><span class="pre">&quot;dictionary&quot;</span></code>, will (covert if needed and) store the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> in this format type. By initializing the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> format as all in the above example, we simply make sure that the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> instance will contain both adjacency and dictionary graph representations and their corresponding edge and adjacency labels for both nodes and edges. Although the methods <code class="code docutils literal notranslate"><span class="pre">get_adjacency_matrix</span></code> and <cite>get_edge_dictionary</cite>, construct and return such a graph representation if non existent, the <code class="code docutils literal notranslate"><span class="pre">get_labels</span></code> method will change the graph format if the requested labels are not in the desired format and pop a certain warning. If the user wants to avoid doing so he can either set the explicit format afterwards by executing</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">adj_graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">H2O</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">H2O_labels</span><span class="p">,</span> <span class="n">H2O_edge_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj_graph</span><span class="o">.</span><span class="n">set_format</span><span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>or declare which is the desired format format he wants the graph to support and it will be included automatically by executing</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">adj_graph</span><span class="o">.</span><span class="n">desired_format</span><span class="p">(</span><span class="s2">&quot;dictionary&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">which in that case will set the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> instance format from <code class="code docutils literal notranslate"><span class="pre">&quot;adjacency&quot;</span></code> to <code class="code docutils literal notranslate"><span class="pre">&quot;all&quot;</span></code>, in order to include the specified format.</p>
</div>
<p>After this long introduction of what the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> Object is, the way this can interest the user is by utilizing as input for <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code>.
Because this Object will act as a mutable-object, any necessary format conversion inside a dataset will happen only ones and the user can execute
multiple kernels on a single dataset with repeating conversions again and again. An important thing to mention here is that a kernel Object <strong>should
not</strong> cause information loss concerning a the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> data Object given as input.</p>
<p>Now let’s demonstrate the simple water example on a Shortest-Path kernel, using <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> type objects.
First initialize those objects:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H3O</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;H&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>And calculate fit transform</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;shortest_path&quot;</span><span class="p">},</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">([</span><span class="n">H2O</span><span class="p">])</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>and finally the normalized kernel value, between <span class="math notranslate nohighlight">\(\mathbf{H}_{2}\mathbf{O}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{H}_{3}\mathbf{O}^{+}\)</span></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">H3O</span><span class="p">])</span>
<span class="go">0.9428090415820634</span>
</pre></div>
</div>
<p>which is equivalent with the originally computation, we did on introduction.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="creating_kernels.html" class="btn btn-neutral float-right" title="Creating your Own Kernel" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="introduction.html" class="btn btn-neutral float-left" title="A Short Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, DaSciM (BSD License)

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>