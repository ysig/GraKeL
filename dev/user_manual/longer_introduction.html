

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>A longer Introduction &mdash; GraKeL 0.1a documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/_static/suplementary.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="GraKeL 0.1a documentation" href="../index.html"/>
        <link rel="next" title="Write your own kernel" href="make_your_own_kernel.html"/>
        <link rel="prev" title="A short Introduction" href="introduction.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> GraKeL
          

          
          </a>

          
            
            
              <div class="version">
                0.1a
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installing grakel</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">A short Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">A longer Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-is-the-graphkernel-class">What is the <cite>GraphKernel</cite> class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-kernel-class">The <cite>kernel</cite> class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#why-not-a-more-structured-input-for-graphs">Why not a more structured input for Graphs?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="make_your_own_kernel.html">Write your own kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api.html">GraKeL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../classes.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">General examples</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GraKeL</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>A longer Introduction</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/user_manual/longer_introduction.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="a-longer-introduction">
<span id="longer-introduction"></span><h1>A longer Introduction<a class="headerlink" href="#a-longer-introduction" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-is-the-graphkernel-class">
<h2>What is the <cite>GraphKernel</cite> class<a class="headerlink" href="#what-is-the-graphkernel-class" title="Permalink to this headline">¶</a></h2>
<p><cite>GraphKernel</cite> is a class decorator, which means that it takes a collection of classes, in our case Graph-Kernels and creates a uniform interface for all them, while providing the user with a way of adding various features.</p>
<p>These features can be listed as follows:</p>
<ul>
<li><p class="first"><code class="code docutils literal notranslate"><span class="pre">kernel</span></code> : The kernel can be either a <code class="code docutils literal notranslate"><span class="pre">base_kernel</span></code> or a list of <code class="code docutils literal notranslate"><span class="pre">general_kernels</span></code> that end in a <code class="code docutils literal notranslate"><span class="pre">base_kernel</span></code>.</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><code class="code docutils literal notranslate"><span class="pre">base_kernel</span></code> :</dt>
<dd><p class="first">To initialize a <code class="code docutils literal notranslate"><span class="pre">base_kernel</span></code> kernel the procedure is simple. Any <code class="code docutils literal notranslate"><span class="pre">base_kernel</span></code> is a dictionary containing its name under the <code class="code docutils literal notranslate"><span class="pre">'name'</span></code> field and its parameterization on separate fields that signify kernel parameters and their values. The <code class="code docutils literal notranslate"><span class="pre">shortest_path</span></code> kernel we show on the introduction is such a kernel.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The decorator sometimes wraps two kernels in one (as in the <code class="code docutils literal notranslate"><span class="pre">multiscale_laplacian</span></code> and <code class="code docutils literal notranslate"><span class="pre">multiscale_laplacian_fast</span></code>) and in order to learn
the meaning of each parameter the user is suggested to read the documentation found on <a class="reference internal" href="../kernels.html#kernels"><span class="std std-ref">Kernels (between graphs)</span></a>.</p>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="code docutils literal notranslate"><span class="pre">general_kernels</span></code> :</dt>
<dd><p class="first last">This type of kernels takes as a <code class="code docutils literal notranslate"><span class="pre">base_kernel</span></code> another kernel object. This kernel is also a dictionary containing its name under the <code class="code docutils literal notranslate"><span class="pre">'name'</span></code> field and its
parameterization on separate fields that signify kernel parameters and their values. The kernel produced from all the rest kernels in the list is considered as a <code class="code docutils literal notranslate"><span class="pre">base_kernel</span></code> and its parametrization, can be applied on the list consecutive elements. The <code class="code docutils literal notranslate"><span class="pre">weisfeiler_lehman</span></code> we show on the introduction is such a kernel.</p>
</dd>
</dl>
</li>
</ul>
<p>If no parameters are given at parametrization, default values are assigned.</p>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt><code class="code docutils literal notranslate"><span class="pre">normalize</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">Any kernel has the ability to provide a normalized output. This is important because otherwise the user should calculate the whole kernel matrix at the <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code> stage in order to make a valid normalize representation of the kernel matrix. Code example:</span></dt>
<dd><p class="first">Say we have a <code class="code docutils literal notranslate"><span class="pre">G_train</span></code>, <code class="code docutils literal notranslate"><span class="pre">G_test</span></code>. This</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;niter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;subtree_wl&quot;</span><span class="p">}],</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Calculate the kernel matrix.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_train</span> <span class="o">=</span> <span class="n">gk</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">G_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_test</span> <span class="o">=</span> <span class="n">gk</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">G_test</span><span class="p">)</span>
</pre></div>
</div>
<p>should be equivalent as process (set aside a non-deterministic kernel or split), with this</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;niter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;subtree_wl&quot;</span><span class="p">}],</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Calculate the kernel matrix.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">gk</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_diag</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_train_diag</span><span class="p">,</span> <span class="n">K_test_diag</span> <span class="o">=</span> <span class="n">K_diag</span><span class="p">[</span><span class="n">train_diag</span><span class="p">],</span> <span class="n">K_diag</span><span class="p">[</span><span class="n">test_diag</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_train</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">train_indices</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">train_indices</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">K_train_diag</span><span class="p">,</span> <span class="n">K_train_diag</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_test</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">test_indices</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">train_indices</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">K_test_diag</span><span class="p">,</span> <span class="n">K_train_diag</span><span class="p">))</span>
</pre></div>
</div>
<p class="last">but in the second case we make some more computations, in reward that fit samples are drown from both
train and test datasets, producing a different result in some kernels by unifying as a intuitively
train and test data when drawing samples and may be desired (e.g. on the <code class="code docutils literal notranslate"><span class="pre">multiscale_laplacian_fast</span></code>).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="code docutils literal notranslate"><span class="pre">Nystroem</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">Nystroem is very well known method, for approximating kernel matrices on huge datasets.</span></dt>
<dd><p class="first">The kernel matrix is calculated only in random drown subsets of graphs, whose size can be defined by the user
by setting an int value inside the <code class="code docutils literal notranslate"><span class="pre">Nystroem</span></code> parameter. After that, all the kernel values are calculated
in the sample space. An example indicating the power of nystroem can be indicated below:</p>
<div class="line-block">
<div class="line">Example: We will perform a simple classification task.</div>
</div>
<p>Download the dataset and split to train and test</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MUTAG</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">fetch_dataset</span><span class="p">(</span><span class="s2">&quot;MUTAG&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MUTAG_data</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_point</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MUTAG_data</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">MUTAG_data</span><span class="p">[:</span><span class="n">split_point</span><span class="p">],</span> <span class="n">MUTAG_data</span><span class="p">[</span><span class="n">split_point</span><span class="p">:]</span>
</pre></div>
</div>
<p>Initialise a <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code>, using <code class="code docutils literal notranslate"><span class="pre">Nystroem</span></code> of 20 samples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wl_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;niter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;subtree_wl&quot;</span><span class="p">}],</span> <span class="n">Nystroem</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_train</span> <span class="o">=</span> <span class="n">wl_kernel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_test</span> <span class="o">=</span> <span class="n">wl_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">K_train</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(169, 10)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">K_test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(19, 10)</span>
</pre></div>
</div>
<p>Classify using a standard SVC</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="n">split_point</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">split_point</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">svm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">SVC</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">K_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="go">SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,</span>
<span class="go">  decision_function_shape=&#39;ovr&#39;, degree=3, gamma=&#39;auto&#39;, kernel=&#39;rbf&#39;,</span>
<span class="go">  max_iter=-1, probability=False, random_state=None, shrinking=True,</span>
<span class="go">  tol=0.001, verbose=False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">K_test</span><span class="p">)</span>
</pre></div>
</div>
<p>finnaly calculate accuracy score</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="s2">&quot;%&quot;</span><span class="p">)</span>
<span class="go">78.95 %</span>
</pre></div>
</div>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<div class="last line-block">
<div class="line">As we see the accuracy of the classification is the same, allthough instead of doing</div>
<div class="line">~ 169 * (169-1) /2 + 19 * 169 = 17,407 computations we did</div>
<div class="line">~ 20 * (20-1)/ 2 + 20 * 169 + 20* 19 = 3,950 computations.</div>
</div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="code docutils literal notranslate"><span class="pre">n_jobs</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">Some kernels have operations that can be executed concurrently, making computation faster</span></dt>
<dd><p class="first">when user uses a significant amount of data, to overcome the parallelization overhead. <code class="code docutils literal notranslate"><span class="pre">n_jobs</span></code> follows
the same formulation as in sklearn where giving as input 0 or -1 <code class="code docutils literal notranslate"><span class="pre">n_jobs</span></code> signifies initializing all the
possible workers and if given a positive number, initializes that amount of workers if possible.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This feature is currently not implemented correctly and we would advise the user not to use.</p>
</div>
<p class="last">For helping us solve such a problem see <a class="reference internal" href="contributing.html#contributing"><span class="std std-ref">Contributing</span></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="code docutils literal notranslate"><span class="pre">random_seed</span></code> <span class="classifier-delimiter">:</span> <span class="classifier">We would in generally want to satisfy the need of the user to provide</span></dt>
<dd><p class="first">a <code class="code docutils literal notranslate"><span class="pre">random_seed</span></code> either to kernels that are probabilistic, or to randomize accordingly
procedures of the <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code> that need randomization such as <code class="code docutils literal notranslate"><span class="pre">Nystroem</span></code>, where the
decorator draws probabilistically a number of components from the number of fitted samples.</p>
<p>Let’s give an example of a probabilistic kernel using our old water example. We will use a very well known kernel called <em>Graphlet-Sampling</em>, where we will
sample probabilistically 5 subgraph samples from each graph either <img class="math" src="../_images/math/0f5aa0b3c5dbb09e4d0e74b9faa856646d7eb87d.png" alt="\mathbf{H}_{2}\mathbf{O}"/> or <img class="math" src="../_images/math/b6a74bb3e538c404c065e7ba2b71ef2cb76891b8.png" alt="\mathbf{H}_{3}\mathbf{O}^{+}"/>.</p>
<p>After initializing the input</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span> <span class="o">=</span> <span class="p">[[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">}]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H3O</span> <span class="o">=</span> <span class="p">[[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;H&#39;</span><span class="p">}]]</span>
</pre></div>
</div>
<p>let’s calculate a default kernel value</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gs_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;graphlet_sampling&quot;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gs_kernel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">H2O</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gs_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">H3O</span><span class="p">)</span>
<span class="go">20.0</span>
</pre></div>
</div>
<p>Note that if a random seed is not given as an argument either to the <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code> or to the kernel parameters
a default will be used. Now let’s try to give one as a parameter of the kernel (say 3)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gs_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;graphlet_sampling&quot;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
<span class="n">gs_kernel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">H2O</span><span class="p">)</span>
<span class="n">gs_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">H3O</span><span class="p">)</span>
<span class="mf">10.0</span>
</pre></div>
</div>
<p>As we see a new value has been calculated because the default seed is now not used. If know a <code class="code docutils literal notranslate"><span class="pre">random_seed</span></code>
is initialized inside the decorator and no parameter is given signifying a <code class="code docutils literal notranslate"><span class="pre">random_seed</span></code> to the <code class="code docutils literal notranslate"><span class="pre">kernel</span></code>
argument then if the kernel has such parameter the default will be used. This is demonstrated in what follows</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gs_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;graphlet_sampling&quot;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">gs_kernel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">H2O</span><span class="p">)</span>
<span class="n">gs_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">H3O</span><span class="p">)</span>
<span class="mf">10.0</span>
</pre></div>
</div>
<p>where we get the same result. Now if both a <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code> has a <code class="code docutils literal notranslate"><span class="pre">random_seed</span></code> and the <code class="code docutils literal notranslate"><span class="pre">kernel</span></code> is provided
with one inside parametrization, the second will be used inside the <code class="code docutils literal notranslate"><span class="pre">kernel</span></code> and the first outside, in the rest code area
covered by the decorator, as expected. To demonstrate show is the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gs_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;graphlet_sampling&quot;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gs_kernel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">H2O</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gs_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">H3O</span><span class="p">)</span>
<span class="go">10.0</span>
</pre></div>
</div>
<p>where</p>
<div class="last highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gs_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;graphlet_sampling&quot;</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gs_kernel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">H2O</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gs_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">H3O</span><span class="p">)</span>
<span class="go">15.0</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="code docutils literal notranslate"><span class="pre">verbose</span></code> :</dt>
<dd><div class="first last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Verbose is an argument that is currently unsupported (has no impact), but is set for future implementation of some output messages.</p>
</div>
</dd>
</dl>
</li>
</ul>
<p>To understand what the <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code> object is doing, we must see inherently what objects it decorates.</p>
</div>
<div class="section" id="the-kernel-class">
<h2>The <cite>kernel</cite> class<a class="headerlink" href="#the-kernel-class" title="Permalink to this headline">¶</a></h2>
<p>This <code class="code docutils literal notranslate"><span class="pre">Object</span></code> is any object inherited from the <a class="reference internal" href="../kernels/kernel.html#kernel"><span class="std std-ref">kernel (class)</span></a> class (which can be imported from <code class="code docutils literal notranslate"><span class="pre">grakel</span></code>).</p>
<p>Normally a kernel function, between graphs should be considered as a function with to arguments,
such as <img class="math" src="../_images/math/f91cfc75af5b411b0563758bf70b730ed8949c15.png" alt="k \; : \; \mathcal{G} \times \mathcal{G} \rightarrow \mathbb{R}"/>.
This raises two issues, namely one of efficiency and one of compatibility:
1. The first one has to do with the fact, that there are major computational advantages if instead of calculating the kernel pairwise, we calculate the whole kernel matrix.
2. The second has to do with the fact, that we wanted our project to be integratable inside the <a class="reference external" href="https://github.com/scikit-learn-contrib/project-template">sk learn template</a>. From this template the most relevant structure was the sci-kit transformer, which consists of three inherent methods: <code class="code docutils literal notranslate"><span class="pre">fit</span></code>, <code class="code docutils literal notranslate"><span class="pre">fit-transform</span></code>, <code class="code docutils literal notranslate"><span class="pre">transform</span></code>.</p>
<p>So the way we conceptually attached the kernel definition to that design pattern was
+ The <code class="code docutils literal notranslate"><span class="pre">fit</span></code> part should fix a graph dataset as the base of comparison calculating necessary features.
+ The <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code> should fit and calculate the fitted dataset with itself.
+ The <code class="code docutils literal notranslate"><span class="pre">transform</span></code> should calculate the matrix produced by between a new dataset (namely the <em>test</em>) and the dataset fitted in fit.</p>
<p>The deconstruction of the kernel matrix calculation from a function <img class="math" src="../_images/math/a4301f1553dae347454e8ef973d372480fe6477d.png" alt="\mathcal{K}: \mathcal{G}^{\text{train}} \times \mathcal{G}^{\text{test}} \rightarrow \mathbb{R}^{n_{\text{test}}} \times \mathbb{R}^{n_{\text{train}}}"/>
to a <a class="reference external" href="https://en.wikipedia.org/wiki/Currying">currying</a> scheme <img class="math" src="../_images/math/34e6962b12b99b4ffe9c9f23194841c4065b6874.png" alt="\mathcal{K}: \mathcal{G}^{\text{train}} \rightarrow \mathcal{G}^{\text{test}} \rightarrow \mathbb{R}^{n_{\text{test}}} \times \mathbb{R}^{n_{\text{train}}}"/> is not always equivalent in the
result, if some of the data of <img class="math" src="../_images/math/f090d84290ea186bfc545c4795548e2a85df2530.png" alt="\mathcal{G}^{\text{train}}"/>, must be combined with data of <img class="math" src="../_images/math/d1e2e89b7013bbe559686f617928406fd64f09dc.png" alt="\mathcal{G}^{\text{test}}"/> to produce the fit reference-features. In such cases
as mentioned above, namely in the case of <code class="code docutils literal notranslate"><span class="pre">multiscale_laplacian</span></code>, if the user wants <img class="math" src="../_images/math/47802fb866adff114d07b12af5ccf0101b99f5c4.png" alt="\mathcal{G}^{\text{train}} \rightarrow \mathcal{G}^{\text{test}}"/> to be concerned
before fit we advise him to use the <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code>, function in the whole of the train and test data and separate the kernel matrices on the result.</p>
<p>Using a <code class="code docutils literal notranslate"><span class="pre">kernel</span></code> type object through the decorator, should be equivalent with doing so from the decorator, if the correct parametrization is given.
The decorator <strong>does not</strong> restrict any <em>user-oriented</em> interface of the kernels except if the user wants to write a kernel of his own.
If you want to know more about the kernel structure in order to write your own see <a class="reference internal" href="make_your_own_kernel.html#myok"><span class="std std-ref">Write your own kernel</span></a>.</p>
<p>To demonstrate a small example of the above we will construct our own a WL-subtree kernel instead of using the decorator.
To do so first import the <code class="code docutils literal notranslate"><span class="pre">weisfeiler_lehman</span></code> and <code class="code docutils literal notranslate"><span class="pre">subtree_wl</span></code> kernels as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">weisfeiler_lehman</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">subtree_wl</span>
</pre></div>
</div>
<p>If we see the documentation of <a class="reference internal" href="../kernels/weisfeiler_lehman.html#weisfeiler-lehman"><span class="std std-ref">Weisfeiler Lehman Kernel</span></a>, we can see that it accepts two arguments upon initialization: a <code class="code docutils literal notranslate"><span class="pre">niter</span></code> and a <code class="code docutils literal notranslate"><span class="pre">base_kernel</span></code>. The <code class="code docutils literal notranslate"><span class="pre">base_kernel</span></code> is a tuple consisting of a <code class="code docutils literal notranslate"><span class="pre">kernel</span></code> type object and a dictionary of arguments. To initialize a Weisfeiler-Lehman with 5 iterations and a subtree base-kernel.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wl_kernel</span> <span class="o">=</span> <span class="n">weisfeiler_lehman</span><span class="p">(</span><span class="n">niter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">base_kernel</span><span class="o">=</span><span class="p">(</span><span class="n">subtree_wl</span><span class="p">,</span> <span class="p">{}))</span>
</pre></div>
</div>
<p>This is also equivalent with doing (as long as we have no arguments)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wl_kernel</span> <span class="o">=</span> <span class="n">weisfeiler_lehman</span><span class="p">(</span><span class="n">niter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">base_kernel</span><span class="o">=</span><span class="n">subtree_wl</span><span class="p">)</span>
</pre></div>
</div>
<p>Now let’s go back again to our favorite MUTAG problem.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MUTAG</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">fetch_dataset</span><span class="p">(</span><span class="s2">&quot;MUTAG&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MUTAG_data</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">split_point</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MUTAG_data</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">MUTAG_data</span><span class="p">[:</span><span class="n">split_point</span><span class="p">],</span> <span class="n">MUTAG_data</span><span class="p">[</span><span class="n">split_point</span><span class="p">:]</span>
</pre></div>
</div>
<p>If what we said till now is correct, the <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code> object should produce the same kernel matrix output on the MUTAG train/test data split.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wl_graph_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;niter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;subtree_wl&quot;</span><span class="p">}])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array_equal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array_equal</span><span class="p">(</span><span class="n">wl_graph_kernel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">wl_kernel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array_equal</span><span class="p">(</span><span class="n">wl_graph_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span> <span class="n">wl_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">Y</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="why-not-a-more-structured-input-for-graphs">
<h2>Why not a more structured input for Graphs?<a class="headerlink" href="#why-not-a-more-structured-input-for-graphs" title="Permalink to this headline">¶</a></h2>
<p>The flattened input type provided for all kernels (graph-dictionary/adjacency, node-labels, edge-labels) may raise the question,
why does not this library, accept a well known type of Graph input as the one constructed from <a class="reference external" href="https://networkx.github.io/">networkx</a> or <a class="reference external" href="http://igraph.org/python/">igraph</a>.
Networkx library is known for producing a very big memory overhead, which seems unimportant when the user wants to use
very basic graph methods such calculating shortest paths or getting a vertex neighbor. Because what we wanted to wrap
around a graph class was really simple: conversion between dictionary and adjacency formats, format agnostic - format imposing
methods and very basic graph oriented supplementary methods, such as <em>Shortest-Path matrix</em> calculation, we designed
a Graph class of our own, used inside most of our kernels, in order to resolve to a common object - graph format reference.
This specificity of kernel format, as well as the absence of a need for complex calculations concerning the field of graphs
lead us to the creation of <a class="reference internal" href="../graph.html#graph"><span class="std std-ref">Graph (class)</span></a>.</p>
<p>Let’s go back to the H2O example:
First we will import the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> object from <code class="code docutils literal notranslate"><span class="pre">Grakel</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">Graph</span>
</pre></div>
</div>
<p>Firstly let’s collect all the dictionary formats and show that they are equivalent.
We start by calculating a graph object for the native format of graph dictionary which corresponds to the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">},</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}}</span>
</pre></div>
</div>
<p>Now let’s initialize all the other</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">):</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="mf">1.</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)]</span>
</pre></div>
</div>
<p>and compute the result</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">any</span><span class="p">(</span><span class="n">Graph</span><span class="p">(</span><span class="n">H2Od</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">get_edge_dictionary</span><span class="p">()</span> <span class="o">==</span> <span class="n">H2Od</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Now let’s do the same for adjacency matrix type formats. The numpy array is the native adjacency-matrix format:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
</pre></div>
</div>
<p>and with the conversion of other input type formats</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>we can demonstrate equality as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array_equal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">all</span><span class="p">(</span><span class="n">array_equal</span><span class="p">(</span><span class="n">Graph</span><span class="p">(</span><span class="n">H2O</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">get_adjacency_matrix</span><span class="p">(),</span> <span class="n">H2O</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Now we would like to initialize two <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> type objects one for adjacency_matrix and one for edge_dictionary and show that they are equivalent (using also labels).
First initialize the graph object, created from an adjacency matrix:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2O_labels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O_edge_labels</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj_graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">H2O</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">H2O_labels</span><span class="p">,</span> <span class="n">H2O_edge_labels</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>and one from an edge dictionary:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od_labels</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od_edge_labels</span> <span class="o">=</span> <span class="p">{(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edge_dict_graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">H2Od</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">H2Od_labels</span><span class="p">,</span> <span class="n">H2Od_edge_labels</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Firstly we will demonstrate equality of graph type formats:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">array_equal</span><span class="p">(</span><span class="n">adj_graph</span><span class="o">.</span><span class="n">get_adjacency_matrix</span><span class="p">(),</span> <span class="n">edge_dict_graph</span><span class="o">.</span><span class="n">get_adjacency_matrix</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">adj_graph</span><span class="o">.</span><span class="n">get_edge_dictionary</span><span class="p">()</span> <span class="o">==</span> <span class="n">edge_dict_graph</span><span class="o">.</span><span class="n">get_edge_dictionary</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>and afterwards between labels for <code class="code docutils literal notranslate"><span class="pre">&quot;adjacency&quot;</span></code> object formats, defined by the <code class="code docutils literal notranslate"><span class="pre">purpose</span></code> argument of the <code class="code docutils literal notranslate"><span class="pre">get_labels</span></code> method from the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> type object and for both vertices or edges defined by the <code class="code docutils literal notranslate"><span class="pre">label_type</span></code> format of the same method, as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">all</span><span class="p">((</span><span class="n">adj_graph</span><span class="o">.</span><span class="n">get_labels</span><span class="p">(</span><span class="n">purpose</span><span class="o">=</span><span class="s2">&quot;adjacency&quot;</span><span class="p">,</span> <span class="n">label_type</span><span class="o">=</span><span class="n">lt</span><span class="p">),</span> <span class="n">edge_dict_graph</span><span class="o">.</span><span class="n">get_labels</span><span class="p">(</span><span class="n">purpose</span><span class="o">=</span><span class="s2">&quot;adjacency&quot;</span><span class="p">,</span> <span class="n">label_type</span><span class="o">=</span><span class="n">lt</span><span class="p">))</span> <span class="k">for</span> <span class="n">lt</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;vertex&quot;</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking equality of the inverse (“edge_dictionary”) want hold, because the adjacency matrix, when initialized does not have information about the vertex symbols.
Here we should emphasize that <strong>vertex symbols should be a :code:`sortable` in order for an indexing to be possible</strong>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>When initializing a <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> object the 4th argument (named <code class="code docutils literal notranslate"><span class="pre">graph_format</span></code>), corresponds to the format the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> will be stored to. The default value of this argument is <code class="code docutils literal notranslate"><span class="pre">&quot;auto&quot;</span></code>, which stores the graph in the given format, if it is valid. Explicit format “choices” such as <code class="code docutils literal notranslate"><span class="pre">&quot;adjacency&quot;</span></code> or <code class="code docutils literal notranslate"><span class="pre">&quot;dictionary&quot;</span></code>, will (covert if needed and) store the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> in this format type. By initializing the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> format as all in the above example, we simply make sure that the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> instance will contain both adjacency and dictionary graph representations and their corresponding edge and adjacency labels for both nodes and edges. Although the methods <code class="code docutils literal notranslate"><span class="pre">get_adjacency_matrix</span></code> and <cite>get_edge_dictionary</cite>, construct and return a such a graph representation, if non existent, and return it, the <code class="code docutils literal notranslate"><span class="pre">get_labels</span></code> method will change the graph format if the requested labels are not in the desired format and pop a certain warning. If the user wants to avoid doing so he can either set the explicit format afterwards by executing</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">adj_graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">H2O</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">H2O_labels</span><span class="p">,</span> <span class="n">H2O_edge_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj_graph</span><span class="o">.</span><span class="n">set_format</span><span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>or declare which is the desired format format he wants the graph to support and it will be included automatically by executing</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">adj_graph</span><span class="o">.</span><span class="n">desired_format</span><span class="p">(</span><span class="s2">&quot;dictionary&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">which in that case will set the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> instance format from <code class="code docutils literal notranslate"><span class="pre">&quot;adjacency&quot;</span></code> to <code class="code docutils literal notranslate"><span class="pre">&quot;all&quot;</span></code>, in order to include the specified format.</p>
</div>
<p>After this long introduction of what the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> Object is, the way this can interest the user is by utilizing as input for <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code>.
Because this Object will act as a mutable-object, any necessary format conversion inside a dataset will happen only ones and the user can execute
multiple kernels on a single dataset with repeating conversions again and again. An important thing to mention here is that a kernel Object <strong>should
not</strong> cause information loss concerning a the <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> data Object give as input.</p>
<p>Now let’s demonstrate the simple water example on a Shortest-Path kernel, using <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> type objects.
First initialize those objects:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H3O</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;H&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>And calculate fit transform</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;shortest_path&quot;</span><span class="p">},</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">([</span><span class="n">H2O</span><span class="p">])</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>and finally the normalized kernel value, between <img class="math" src="../_images/math/0f5aa0b3c5dbb09e4d0e74b9faa856646d7eb87d.png" alt="\mathbf{H}_{2}\mathbf{O}"/> and <img class="math" src="../_images/math/b6a74bb3e538c404c065e7ba2b71ef2cb76891b8.png" alt="\mathbf{H}_{3}\mathbf{O}^{+}"/></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">H3O</span><span class="p">])</span>
<span class="go">0.9428090415820634</span>
</pre></div>
</div>
<p>which is equivalent with the originally computation, we did on introduction.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="make_your_own_kernel.html" class="btn btn-neutral float-right" title="Write your own kernel" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="introduction.html" class="btn btn-neutral" title="A short Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, DaSciM (BSD License).

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1a',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>